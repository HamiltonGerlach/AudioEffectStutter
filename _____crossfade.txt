


fadeB = (float)head / length;
fadeA = 1.0f - fadeB;

mirror = (int)(offset + fadeA * length) % STUTTER_QUEUE_END;


// Serial.print(index); Serial.print("; "); Serial.println(mirror);
// dist = floor(length / 2) - index;
// mirror = (int)(floor(length / 2) + 1 + dist) % STUTTER_QUEUE_END;


// if (queue[index]) { pa = (int16_t *)(queue[index]->data); } //{ transmit(queue[index]); }
// if (!queue[mirror]) { release(block); break; }

fadeBlock = allocate();
release(block);


if (queue[index] && queue[mirror])
{
    cache = (int16_t *)fadeBlock->data;
    pa = (int16_t *)queue[index]->data;
    pma = (int16_t *)queue[index]->data;
    
    
    for (int i = 0; i < AUDIO_BLOCK_SAMPLES; i++) {
        sample = *pa;
        s_cache = *pma;
        *cache = (int16_t)(sample * fadeA + s_cache * fadeB);
        //Serial.print(*pma); Serial.print("; ");
        pa++; pma++; cache++;
    }
    Serial.println("");
    
} 
// else
// {
//     if (queue[index]) {
//         cache = (int16_t *)fadeBlock->data;
//         pa = (int16_t *)queue[index]->data;
//         memcpy(cache, pa, sizeof(int16_t) * AUDIO_BLOCK_SAMPLES);
//     }
// }

transmit(fadeBlock);
release(fadeBlock);

head = (head < (length - 1)) ? head + 1 : 0;
break;






// pa = (int16_t *)(block->data);
// 
// Serial.print(*pa); Serial.print(" : ");
// Serial.print(*(pa+1)); Serial.print(" : ");
// Serial.print(*(pa+2)); Serial.print(" : ");
// Serial.print(*(pa+3)); Serial.print(" : ");
// Serial.print(*(pa+4)); Serial.print(" : ");
// Serial.print(*(pa+5)); Serial.print(" : ");
// Serial.print(*(pa+6)); Serial.print(" : ");
// Serial.println(*(pa+7));
// 










case 0: // Latch mode
    
    if (SwitchPressed && ((ms - SwitchTimer) > RETRIGGER_EXIT_TIME))
    {
        stutter.unlatch(); LED.Flush();
    }
    
    // Stutter / Looper control
    if (btn.fallingEdge())
    {
        SwitchPressed = true;
        SwitchTimer = ms;
        
        if (!stutter.isActive()) {
            stutter.snap();
            LED.SetRGB(0.0f, 0.25f, 0.0f);
            
            if (Retrigger) { LED.SetR(0.125f); }
        } else {
            if (stutter.isLatched() && !Retrigger) { 
                stutter.dub();
                LED.SetRGB(0.125f, 0.25f, 0.25f);
            }
            else {
                stutter.unlatch(); LED.Flush();
            
                if (Retrigger) {
                    stutter.snap();
                    LED.SetRGB(0.125f, 0.25f, 0.0f);
                }
            }
        }
    }
    else if (btn.risingEdge())
    {
        SwitchPressed = false;
        
        if (stutter.isActive()) {
            stutter.latch(); LED.SetRGB(0.0f, 0.0f, 0.25f);
            if (Retrigger) { LED.SetR(0.125f); }
        }
    }
    
    break;
    
    
    
    
    
    
    
    
    
    
    case 1: // Momentary mode, heads locked
    case 2: // Momentary mode, heads unlocked
    case 3: // Momentary mode, short tap loops
        
    
        if (MomentarySnapped && ((ms - SwitchTimer) > LoopLength)) {
            MomentarySnapped = false;
            stutter.latch(); LED.SetRGB(0.25f, 0.25f, 0.0f);
        }
        
        
        if ((LoopMode >= 2) && SwitchPressed && ((ms - SwitchTimer) > RETRIGGER_EXIT_TIME))
        {
            stutter.unlatch(); LED.Flush();
        }
        
        if (stutter.isLatched() && (ms - SwitchTimer) >= MOMENTARY_FREEZE_TIMER) {
            MomentarySnapped = false;
            if (LoopMode == 3) {// != 3
            // {
            //     stutter.unlatch(); LED.Flush();
            // }
            // else {
            
                // if (digitalRead(PIN_SWITCH) == LOW)
                // {
                //     FreezeBlinking = false;
                //     stutter.unlatch();
                //     LED.Flush();
                // }
            } else {
                
                if (!FreezeBlinking) // start blinking routine
                {
                    FreezeBlinking = true;
                    FreezeBlinkTimer = ms;
                    LED.SetRGB(0.125f, 0.125f, 0.125f);
                }
                else {
                    int BlinkPhase = (ms - FreezeBlinkTimer) % 200;
                    if (BlinkPhase < 100) {
                        LED.SetRGB(0.125f, 0.125f, 0.125f);
                    }
                    else
                    {
                        LED.Flush();
                    }
                }
            }
        }
        
        if (btn.fallingEdge())
        {
            SwitchPressed = true;
            
            SwitchTimer = ms;
            if (LoopMode == 1) { stutter.unlatch(); }
            if (!MomentarySnapped) {
                if (stutter.isLatched()) {
                    stutter.dub(); 
                    LED.SetRGB(0.125f, 0.25f, 0.25f);
                } else {
                    stutter.snap();
                }
                    
                LED.SetRGB(0.25f, 0.0f, 0.25f);
                MomentarySnapped = true;
            } else {
                MomentarySnapped = false;
                
                if (stutter.isLatched()) {
                    stutter.dub(); 
                    LED.SetRGB(0.125f, 0.25f, 0.25f);
                } else {
                    stutter.snap();
                }
            }
            
        } else if (btn.risingEdge()) {
            
            SwitchPressed = false;
            
            if (((ms - SwitchTimer) < MOMENTARY_FREEZE_TIMER) && (LoopMode == 1))
            {
                MomentarySnapped = false;
                if (LoopMode == 1) { stutter.unlatch(); }
                if (stutter.isLatched()) {
                    stutter.dub();
                    LED.SetRGB(0.125f, 0.25f, 0.25f);
                } else {
                    stutter.snap();
                }
                LED.Flush();
            }
        }
        
        break;